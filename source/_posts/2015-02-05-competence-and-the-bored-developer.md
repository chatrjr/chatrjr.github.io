---
layout: post
title: "Competence and the Bored Developer"
id: 011
categories: personal
date: 2015-02-05
tags:
    - mastery
    - fear
    - craft
description: "There's always been one reason I've pulled away from my keyboard: I was bored."
excerpt: "There's always been one reason I've pulled away from my keyboard: I was bored. I'm beginning to learn that challenge keeps me interested in what I do, and I decided to share my plan for embracing it."
---

I'm what you would call a self-taught developer. I'm educated in information systems, but I barely even touched design or web development until I had to learn, __quickly__, during a job. The resulting website didn't satisfy me. However, my curiosity button had been firmly pushed and my next move was to learn how to build a website properly.

That was a few years ago.

It's not accurate to say my entry into building on the web complemented a natural passion for programming and computer science. My passion for programming and computer science was slowly nurtured and fed by an almost consuming desire to get __really damn good__ at this new thing that was difficult and intriguing to me.

That brings us to now.

## Welcome to Competence Island

Jump ahead and I'm somewhat bored. I realize that's partially my fault as I've had a lot of self-doubt about what I can handle. Sticking to things I know I can build helped me refine that portion of my ability, but it also meant I was slowly losing the challenge. And the challenge is what had me cracking open my text editor at 2 AM just to try something.

The things I've built recently were... not terribly difficult for me, because I now have the knowledge and capability of a competent web developer, but unless I get over my fears and inject difficulty back into my passion for learning the craft, it __will__ dessicate.

For a while, I left web development alone to explore and dabble in other avenues. This led me to do things like trying to pick up Haskell for fun, and the more ridiculous project of trying to code in an assembly language before I knew anything about memory allocation or garbage collection.

I went off on these little tangents partially because experimentation is a huge part of how I learn anything, and partially because of certain fears that were absent while I dabbled.

## Fear of My Own Competence

One concern is feeling like everything I've done up to this point was a fluke and not the result of many hours of practice and play. This is a consequence of giving a shit about the work I produce and whether it's useful to other people. I was worrying too much about how much work had already been done by others and if I really had anything to add to the pool.

However, there isn't just invention (which my ego was preoccupied with), there is also improvement and education. There's the opportunity to contribute to the awesome shit that's already out there, as well as the valuable skill of being able to teach others.

The benefit of pushing past this fear to more difficult projects means not only the return of my focus, but the chance to help others who might deal with similar problems. And that can be just as valuable as new projects.

As I wasn't invested in the Haskell community or the Prolog community the same way I'm invested in the front-end dev community, this fear wasn't able to take hold and my tangents provided a good distraction for a while.

## Fear of Screwing Up

This is the more visceral demon and the last remnant of my early perfectionism. I started to avoid more difficult projects because I was scared of messing up. Especially in a case where someone else would be depending on my competence. I didn't want to make mistakes with someone else's investment on the line, even though that isn't realistic at all.

People make mistakes on others' dime all the time, and the results range from mildly unpleasant to utterly disastrous. My problem is that I've been treating the potential mistakes I'll make as if they'll usher in an apocalypse. And that's not even close to what really happens when a mistake is made: some unpleasant feelings, a sincere apology, and the lesson we can apply to not make the same one.

For the most part, mistakes only become disasters when we attempt to double down as if we haven't made one. That's a recipe for instant disaster.

It's also just not within my power to bring an entire company to its knees with a botched commit. Don't tell that to my doomsaying amygdala, though.

I didn't have this concern while I was fiddling with systems. I didn't have to worry that messing with Linux would cost someone any money. I could just tinker to my heart's content.

## What Happens Now?

Now I find the challenge again. I'm ready to cut down the trees on Competence Island, build a raft, and paddle back out to sea. I've always been __terrible__ at following that "fake it until you make it" advice. That's hardly satisfying for me. 

The only way I'm gonna gain confidence in my ability is by tackling tougher projects and proving to myself that I can handle them. I won't feel as much of a need to question my confidence or competence, because then I'll have the data; __the evidence__ that I belong here.

### The Operation

I'm going to assess my skills and then start aiming for more challenge. Not so challenging that I overwhelm myself, but challenging enough that I have to sweat a little. My growth as a developer thrived in turbulence, so it's time for a little storm chasing.

#### 1. Dive into an Area I Don't Know Well

In my case, that would be working with SVG and canvas. I'm also not that familiar with AngularJS [other than a quick experiment]({% post_url 2014-01-06-mvc-the-angular-way %}). There are many areas I can explore to stretch my competence and see improvement.

#### 2. Deliberate Practice of the Skills I Know

I know there are also things in my current skillset where I can raise the level of challenge. For example: the many new CSS features that have emerged in the last six months. And there's no reason I can't dive a little deeper into the improvements brought to JavaScript by ES6.

#### 3. Focused Experimentation on Weekdays

I mostly create my experiments to cement understanding of the things I learn. However, it can be taken a bit further by experimenting with things I __don't yet understand__. I'll create more projects that will require me to do research on the fuzzy parts. My criteria: if I'm not Googling at least a few times, it's too simple.

#### 4. Frivolous Experimentation on Weekends

I'll leave the end of the week for experiments that let my brain rest and "just because" things. While I do want to get really damn good as a developer, I also want to keep having fun with it.

#### 5. Confront My Own Assumptions

I'm going to start questioning things about my craft and myself that I've taken for granted. I'll kill my assumptions with the wrath of an angry god, because they haven't done much for my progress as a developer or person.

#### 6. Record Myself Coding

This will establish a baseline for review. My memory isn't terrible, but by recording my sessions, I'll have ample material to probe later for any obvious or subtle errors. These mini-screencasts will allow me to catch patterns of error before they become habits. And hell, if musicians can do it then why not developers?

## Conclusion
> %post-body-cap%
![Competence Island](/post-images/island.jpg)
Game on, you stupid island.
