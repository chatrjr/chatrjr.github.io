---
layout: post
title: Code is Only a Method
id: 004
date: 2013-09-11
description: "As much as we love tooling our workflows to be more efficient, it's easy to forget sometimes that they are just tools. This includes the code itself."
excerpt: "As much as we love tooling our workflows to be more efficient, it's easy to forget sometimes that they are just tools. This includes the code itself."
---

I know it has been said hundreds of times already by people much smarter than me, but it's still weird to see posts about vanilla JS vs. CoffeeScript vs. Dart. It's equally strange to see holy wars over pure CSS vs. LESS vs. Sass vs. whatever. It feels a bit petty. Though, I've been petty about that myself.





I completely understand that we can get attached to our tools. I know we can forget that the majority of them are more convenient than essential. It needs to be said again. Over and over until it dissolves in our heads: code is the means, not an end. Whether your app uses Backbone, Angular, or Ember is irrelevant to the majority of its users. **They only care that it works**.





## Never Say Never





One thing I notice as I continue my self-education is that it's pretty damn dangerous to overspecialize. I know I keep repeating it throughout my posts, but there is no One True Way. When it comes to the web---amorphous beast that it is---the answer to "what should I use" is nearly always "it depends". It's incredibly short-sighted to dismiss what you don't use, and programming will march on without you if you get comfortable.





The one thing I've taken from building things on the web is to never say never. Steer clear of statements like:





> 
  I will **never** use [insert framework/language/library/tool], because [insert opinion or anecdote].






Dismissing opportunities to learn because of some personal bias can only hurt you in a field that literally changes every day. Good programmers are not set in their ways. They may specialize, but they never ignore new developments or old lessons.





## Screw Your Job Title





When you tell people what you do, it's okay to use a title like PHP Developer or Rails Developer. Just don't identify with your title too strongly. If you regard yourself as **only** a developer of a certain language or framework, you could be restricting your growth.





Even if they never become a part of your regular workflow, continue learning other methods. Keep your mind fresh with knowledge of new frameworks and languages, and see how they can enhance your work. If you need to, reframe an old problem. You built an app with Rails? Take a weekend and see how far you get with building a similar app with Sinatra. Sass addict? Try building something with Stylus or CSS-Crush. This isn't to replace the way you work, but it does help you to think about your work in new ways.





## Generalist Isn't a Dirty Word





I'll admit my bias is showing a little: I'm a generalist myself. I've never really locked into a niche or specialization with my development. I've dabbled in all sorts of styles and approaches to my design. You could say I'm restless about what I know: I always need to learn more. It's this personality trait that led me down the road of designer to developer. My growth has been circumstantial; escalated by whatever I needed to learn at the time.





I've built on WordPress, but I've never called myself a WordPress developer. I learned shell scripting to speed up my workflow. I build regular experiments, and I never throw out anything I even suspect may be useful later. I constantly reuse snippets and entire scripts, refactoring along the way. The web stack is my focus (HTML/CSS/JS), but I've experimented with PHP, Ruby, Python, Haskell, Assembly, and other languages for the hell of it. I'm a consummate jack-of-all-trades, and that doesn't bother me.





I'm rather happy to play the field with programming. I can't see myself committing to just a few languages or frameworks. I constantly change up my tools until I find the best fit. It seems to me that great programmers are rather fickle about their code and remain skeptical of anything with the word "best" attached.





## What the Market Wants





That said, if employers are demanding certain skills, there's no way around it. You have to learn those skills. Unless you work independently, you are beholden to what your team uses. If you want to work with a company who primarily builds projects with Rails, you'd better learn Rails. Continually keep an eye on the market so you keep a leg up on value, but direct your own education. Just because your employer swears by Node doesn't mean you can never touch a PHP framework.





As a rule: **prioritize that which helps you do your job better**. Most other things are secondary. Just note that secondary doesn't mean irrelevant. Expose yourself to different things and don't sit still. Use some of your free time to pursue personal projects with unfamiliar requirements. Let yourself feel a little uneasy, but don't overwhelm yourself.





### What the User Wants





The user's needs are simple. They just want things to work. The average person isn't going to be able to tell, or even care, whether your photosharing web application is built on Sinatra or Flask, Rails or Django, or even hacked together through judicious use of JavaScript libraries. Only we care about that shit. Only your team cares about that. Only the people who will maintain your app after you're gone care about that.





The average person just cares that your creation **works and works well**. They care that it isn't frustrating to use for themselves and friends. They care that it doesn't take forever to respond. They care if it has a good interface, but that's all they care about. Nothing informs application design and structure more than the needs of your user, and by extension, your interface. Even if that user is you.





## Code is Only One Part of Programming





And hell, it's not even the most important part. Unless you're a hobbyist content with building things for yourself, what you build will be used. Beautiful code, to me, is code that does its job. It's not about clever algorithms and being wily with syntax. It's about giving ideas form. It's about building a codebase that is easy to pick up and extend, so our ideas can continue to grow. It's about understanding the audience and serving their needs. It's about communicating effectively with your team and making awesome shit. Code is only a method.



